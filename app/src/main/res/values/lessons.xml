<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="bubble">
"for i from 1 to N
	for j from 0 to N-1
		if a[j]>a[j+1]
		  swap(a[j], a[j+1])"
    </string>

    <string name="insertion">
"for i from 1 to N
    key = a[i]
    j = i - 1
    while j >= 0 and a[j] > key
        a[j+1] = a[j]
        j = j - 1
    a[j+1] = key"
    </string>
    <string name="selection">
"for i = 1 to n - 1
    min = i
    for j = i+1 to n
        if list[min] > list[j]
        min = j
    if indexMin != i
        swap(list[min], list[i])"
    </string>
    <string name="sorting1">
"   In computer science, a sorting algorithm is an algorithm that puts elements of a list in a certain order.
The most frequently used orders are numerical order and lexicographical order.
Efficient sorting is important for optimizing the efficiency of other algorithms (such as search and merge algorithms) that require input data to be in sorted lists.
More formally, the output of any sorting algorithm must satisfy two conditions:
    1. The output is in non-decreasing order (each element is no smaller than the previous element according to the desired total order);
    2. The output is a permutation (a reordering, yet retaining all of the original elements) of the input."
    </string>
    <string name="sorting2">
"Classification:
&#8226; Computational complexity (worst, average and best behavior) in terms of the size of the list (n). For typical serial sorting algorithms good behavior is O(n log n), with parallel sort in O(log&#8322;n), and bad behavior is O(n&#178;). Ideal behavior for a serial sort is O(n), but this is not possible in the average case. Optimal parallel sorting is O(log n). Comparison-based sorting algorithms need at least Ω(n log n) comparisons for most inputs.
&#8226; Computational complexity of swaps (for "in-place" algorithms).
&#8226; Memory usage (and use of other computer resources). In particular, some sorting algorithms are \"in-place\". Strictly, an in-place sort needs only O(1) memory beyond the items being sorted; sometimes O(log(n)) additional memory is considered \"in-place\".
&#8226; Recursion. Some algorithms are either recursive or non-recursive, while others may be both (e.g., merge sort)."
    </string>
    <string name="sorting3">
"Bubble sort:
Bubble sort is a simple sorting algorithm. The algorithm starts at the beginning of the data set. It compares the first two elements, and if the first is greater than the second, it swaps them.
It continues doing this for each pair of adjacent elements to the end of the data set. It then starts again with the first two elements, repeating until no swaps have occurred on the last pass.
This algorithm's average time and worst-case performance is O(n&#178;), so it is rarely used to sort large, unordered data sets."
    </string>
    <string name="sorting4">
"Insertion sort:
Insertion sort is a simple sorting algorithm that is relatively efficient for small lists and mostly sorted lists, and is often used as part of more sophisticated algorithms.
It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list similar to how we put money in out wallet.
In arrays, the new list and the remaining elements can share the array's space, but insertion is expensive, requiring shifting all following elements over by one."
    </string>
    <string name="sorting5">
"Selection sort:
Selection sort is an in-place comparison sort. It has O(n&#178;) complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort.
Selection sort is noted for its simplicity, and also has performance advantages over more complicated algorithms in certain situations.
The algorithm finds the minimum value, swaps it with the value in the first position, and repeats these steps for the remainder of the list. It does no more than n swaps, and thus is useful where swapping is very expensive."
    </string>
    <string name="graphs1">
"A graph data structure consists of a finite (and possibly mutable) set of vertices (also called nodes or points), together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph.
These pairs are known as edges (also called links or lines), and for a directed graph are also known as arrows.
The vertices may be part of the graph structure, or may be external entities represented by integer indices or references."
    </string>
    <string name="graphs2">
"Undirected graphs:
In an undirected graph, nodes are connected by edges that are all bidirectional.
For example if an edge connects node 1 and 2, we can traverse from node 1 to node 2, and from node 2 to 1."
    </string>
    <string name="graphs3">
"Directed graph:
In a directed graph, nodes are connected by directed edges – they only go in one direction.
For example, if an edge connects node 1 and 2, but the arrow head points towards 2, we can only traverse from node 1 to node 2 – not in the opposite direction."
    </string>
    <string name="graphs4">
"Adjacency list:
To create an Adjacency list, an array of lists is used. The size of the array is equal to the number of nodes.
A single index, array[i] represents the list of nodes adjacent to the ith node."
    </string>
    <string name="graphs5">
"Adjacency matrix:
An Adjacency Matrix is a 2D array of size V x V where V is the number of nodes in a graph.
A slot matrix[i][j] = 1 indicates that there is an edge from node i to node j."
    </string>
    <string name="lists1">
"A linked list is a sequence of data structures, which are connected together via links.
Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array."
    </string>
    <string name="lists2">
"A linked list is a dynamic data structure. The number of nodes in a list is not fixed and can grow and shrink on demand.
Any application which has to deal with an unknown number of objects will need to use a linked list."
    </string>
    <string name="lists3">
"One disadvantage of a linked list against an array is that it does not allow direct access to the individual elements.
If you want to access a particular item then you have to start at the head and follow the references until you get to that item."
    </string>
    <string name="lists4">
"Each element (we will call it a node) of a list is comprising of two items - the data and a reference to the next node.
The last node has a reference to null. The entry point into a linked list is called the head of the list.
It should be noted that head is not a separate node, but the reference to the first node. If the list is empty then the head is a null reference."
    </string>
    <string name="lists5">
"Types of linked lists:
&#8226; Singly linked lists: has a reference to the next node
&#8226; Doubly linked lists: has two references, to the next and to the previous node
&#8226; Circular linked lists: last node of the list points back to the first node (or the head) of the list."
    </string>
    <string name="bst1">
"A binary search tree is a rooted binary tree, whose internal nodes each store a key (and optionally, an associated value) and each have two distinguished sub-trees, commonly denoted left and right.
The tree additionally satisfies the binary search property, which states that the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree."
    </string>
    <string name="bst2">
"Searching:
Searching in a binary search tree for a specific key can be programmed recursively or iteratively.
We begin by examining the root node. If the tree is null, the key we are searching for does not exist in the tree.
Otherwise, if the key equals that of the root, the search is successful and we return the node.
If the key is less than that of the root, we search the left subtree.
Similarly, if the key is greater than that of the root, we search the right subtree."
    </string>
    <string name="bst3">
"Inserting:
In order to insert a new node in the tree, its key is first compared with that of the root. If its key is less than the root's, it is then compared with the key of the root's left child.
If its key is greater, it is compared with the root's right child.
This process continues, until the new node is compared with a leaf node, and then it is added as this node's right or left child, depending on its key"
    </string>
    <string name="bst4">
"Deletion:
When removing a node from a binary search tree it is mandatory to maintain the in-order sequence of the nodes.
&#8226; Deleting a node with no children: simply remove the node from the tree.
&#8226; Deleting a node with one child: remove the node and replace it with its child.
&#8226; Deleting a node with two children: call the node to be deleted D. Choose either its in-order predecessor node or its in-order successor node as replacement node E.
    Copy values of E to D. If E does not have a child, simply remove E from its previous parent G. If E has a child, say F, it is a right child. Replace E with F at E's parent."
    </string>
    <string name="bst5">
"Traversal:
Once the binary search tree has been created, its elements can be retrieved in-order by recursively traversing the left subtree of the root node, accessing the node itself, then recursively traversing the right subtree of the node, continuing this pattern with each node in the tree as it's recursively accessed.
Traversal requires O(n) time, since it must visit every node."
    </string>
    <string name="heaps1">
"A heap is a specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property.
The heap is one maximally efficient implementation of an abstract data type called a priority queue, and in fact, priority queues are often referred to as "heaps", regardless of how they may be implemented.
In a heap, the highest (or lowest) priority element is always stored at the root."
    </string>
    <string name="heaps2">
"In an implicit heap data structure, the first (or last) element will contain the root.
The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc.
Thus the children of the node at position n would be at positions 2n and 2n + 1 in a one-based array, or 2n + 1 and 2n + 2 in a zero-based array"
    </string>
    <string name="heaps3">
"Max-heap:
In a max-heap the key present at the root node must be greatest among the keys present at all of it’s children. The same property must be recursively true for all sub-trees.
In other words,  for any given node C, if P is a parent node of C, then the key of P is greater than or equal to the key of C."
    </string>
    <string name="heaps4">
"Min-heap:
In a min-heap the key present at the root node must be minimum among the keys present at all of it’s children. The same property must be recursively true for all sub-trees"
In other words,  for any given node C, if P is a parent node of C, then the key of P is less than or equal to the key of C."
    </string>
    <string name="heaps5">
"Common operations:
&#8226; find-max (or find-min): find a maximum item of a max-heap, or a minimum item of a min-heap, respectively
&#8226; insert: adding a new key to the heap
&#8226; delete-max (or delete-min): removing the root node of a max heap (or min heap), respectively
&#8226; replace: pop root and push a new key."
    </string>
    <string name="greedy1">
"A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage with the intent of finding a global optimum.
In many problems, a greedy strategy does not usually produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time."
    </string>
    <string name="greedy2">
"If a greedy algorithm can be proven to yield the global optimum for a given problem class, it typically becomes the method of choice because it is faster than other optimization methods like dynamic programming.
Examples of such greedy algorithms are Kruskal's algorithm and Prim's algorithm for finding minimum spanning trees, and the algorithm for finding optimum Huffman trees."
    </string>
    <string name="greedy3">
"Greedy algorithms appear in network routing as well. Using greedy routing, a message is forwarded to the neighboring node which is "closest" to the destination. The notion of a node's location (and hence "closeness") may be determined by its physical location, as in geographic routing used by ad hoc networks.
Location may also be an entirely artificial construct as in small world routing and distributed hash table."
    </string>
    <string name="greedy4">
"Examples of greedy algorithms:
&#8226; Travelling Salesman Problem
&#8226; Dijkstra's Minimal Spanning Tree Algorithm
&#8226; Knapsack Problem
&#8226; Graph - Map Coloring
&#8226; Job Scheduling Problem"
    </string>
    <string name="greedy5">
"Two conditions define the greedy paradigm.
&#8226; Each stepwise solution must structure a problem towards its best-accepted solution.
&#8226; It is sufficient if the structuring of the problem can halt in a finite number of greedy steps."
    </string>
    <string name="rules">
"For learning section:
    1.	Choose a lesson you want to learn
    2.	Read a chapter and then click on Next to load the following chapter
    3.	After completing all 5 chapters, take the quiz by pressing on `Take quiz` button

Quiz:
 &#8226; The quiz consists of 10 questions, each questions having one correct answer out of 4. If the user doesn’t know the answer, he can choose to skip it.
 &#8226; Questions are random and the user can play the quiz multiple times.
 &#8226; At the top right corner you can see the question number.
 &#8226; If you press Skip, you don’t gain any points.

Exercise:
 &#8226; After pressing on the wanted sorting algorithm, you have to press on the ‘Next’ button from the bottom right corner in order to start the exercise.
 &#8226; An array of length 5 is generated. The user has to sort this array step-by-step using the sorting algorithm you have chosen.
 &#8226; The box labeled with “1” is empty. When the user presses on a number from the second box, that box appears in the first box. After filling the first box with 5 numbers, an array with pressed values is created and evaluated to the expected output. If the array entered by the user is the same with the next step of the algorithm, the next iteration starts, if not, the first wrong number is colored in red.
 &#8226; The button from the top-left corner generates a new array and the button from middle bottom deletes an entry."
    </string>
    <string name="about">
"Laera is a tool for learning about some of the most popular sorting algorithms and data structures."
    </string>
    <string name="aboutMe">
"I'm Begum Yuzgulen, student in second year at West University of Timisoara, Faculty of Mathematics and Computer Science.
I love building apps and this is my project for Individual Project course."
    </string>
</resources>